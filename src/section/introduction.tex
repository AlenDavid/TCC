\section{Complexity and Refactoring}

The first step of this article is to explain what is Complexity and how to observe it.

% \cite{article:sonarpaper} starts their paper describing McCabe's Cyclomatic Complexity, as the past tool for
% measuring the complexity of a code, that attempts to be a mathematical model, formulated for Fortran, but not
% includes modern blocks like try/catch and lambdas; it acknowledges this metric as of little use above the method
% level.


Code Complexity is expressed by how much cognitive effort one must provide to understand and maintain a source code
\cite{article:fmricc}. Complexity can also be a model, describing how big and difficult one system is. For this paper,
we decided to use the metrics exported by \cite{article:mozilla}. This tool offers a handful set of metrics researched by
different writes across the Software space. They are separated in four major classes: code size, represented by lines of code;
vocabulary size, by Halstead metrics; control-flow complexity, McCabe's Cyclomatic Complexity; and data-flow complexity.


When the effort to make a significant change increase, \cite{book:refactoring} will recommend one engineer to practice
refactoring. Refactor is a conjunction of defined techniques tool be used as leverage to reduce the amount of time spent
writing code that makes impactful changes in a system.


The goal of this paper is to quantify the impact of those said techniques, not to say when to apply those and where.
To achieve this goal, we will use the tool described above to analyze each JavaScript code implemented for each of the refactor
techniques listed on \cite{book:refactoring}.
