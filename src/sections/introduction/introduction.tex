\section{Code Complexity and Refactoring}

Let us introduce what is Code Complexity and how we planned to observe its entanglements.
In Software engineering, this concept can be expressed by how much cognitive effort one must provide
to understand and maintain a source code \cite{article:fmricc}. This creates a barrier that in most cases
hide bugs and problems.
To measure code complexity, one could start by counting the lines of code they target system have.
Lines of code is usually referenced when discussing code complexity \cite{article:rustcc}.
For example, this paper will count lines of code, physical lines (instructions), logical lines (statements), comment lines and
blank lines.

For \cite{book:refactoring}, refactoring is a conjunction of defined techniques used as a mean to reduce the amount of
time spent writing code that makes impactful changes in a system, without changing the code's behavior. Extract Function,
for example, starts by identifying a sequence of code that is repeated across different files and physically replacing
this same lines with the invocation of a new function, whose body content is that same repeated code.

The goal of this paper is to quantify the impact of those techniques, and not to recommend when and where to apply them.
To achieve this goal, we will use the \cite{article:mozilla} tool to analyze each refactor technique listed on
\cite{book:refactoring} book. This tool offers a handful set of metrics researched by
different writers mentioned in the beginning of this chapter. These metrics are separated in four major classes: code size,
represented by lines of code; vocabulary size, by Halstead metrics; control-flow complexity, McCabe's Cyclomatic
Complexity; data-flow complexity.

\section{Related Work}

\cite{ardito2021evaluation} use Rust and other languages to compare the same solution and check different complexity metrics
from them, in order to evaluate which language is less complex for the same implementation.

\cite{muriana2021comparison} leverages different search algorithms in three languages (Java, Python and C++), while
measuring the resulted complexity between these implementations. In their analysis, C++ takes a lead in linear search but
Python and Java are less complex in binary search. They understand that the three languages are good for bot search algorithms.

\subsection{This Paper Contribution}

While some authors focused on comparing metrics of Software Complexity in different languages, we focused on the comparison
of different strategies of maintaining code. We decided to use \cite{book:refactoring} as a source of code change patterns.
We encourage the reader to pursue the comparison of other authors in this same segment.
