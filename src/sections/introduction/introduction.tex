\section{Code Complexity and Refactoring}

Let us introduce what is Code Complexity and how we planned to observe its entanglements.
In Software engineering, this concept can be expressed by how much cognitive effort one must provide
to understand and maintain a source code \cite{article:fmricc}. This creates a barrier that in most cases
hide bugs and problems.
To measure code complexity, one could start by counting the lines of code they target system have.
Lines of code is usually referenced when discussing code complexity \cite{article:rustcc}.
In this paper, we count lines of code, physical lines (instructions), logical lines (statements), comment lines and
blank lines.


\cite{book:refactoring} refactoring is a conjunction of defined techniques used as a mean to reduce the amount of
time spent writing code that makes impactful changes in a system, without changing the code behavior. Extract Function,
for example, starts by identifying a sequence of code that is repeated across different files and physically replacing
this lines with the invocation of a new function, whose body content is that same repeated code.


The goal of this paper is to quantify the impact of those said techniques, and not to recommend when and where to apply them.
To achieve this goal, we will use the \cite{article:mozilla} tool to analyze each refactor technique listed on
\cite{book:refactoring} book. This tool offers a handful set of metrics researched by
different writers mentioned in the beginning of this chapter. These metrics are separated in four major classes: code size,
represented by lines of code; vocabulary size, by Halstead metrics; control-flow complexity, McCabe's Cyclomatic
Complexity; data-flow complexity.
