\subsection{106. Extract Function}

The "Extract Function" pattern is the opposite of the "Inline Function" pattern. It involves creating a new function (which may also take the form of a method or procedure) by extracting specific lines of code from an existing block. The extracted lines form the body of the newly created function. This pattern proves useful in two main scenarios: managing repeated code and improving code cohesion. Repeated code can be centralized into a single function, reducing redundancy across the application. Similarly, by grouping related operations into a function, the code becomes more cohesive and easier to understand, as its structure better explains its purpose.

Applying this pattern impacts Cyclomatic Complexity, increasing it slightly. For instance, the variable measuring this metric rises by one, reflecting the addition of a new function. This indicates a slight increase in the control flow's complexity within the program.

Halstead metrics, which quantify various aspects of code complexity, also show measurable changes when a function is extracted. For example, the estimated number of bugs increases by a negligible 0.01, while the difficulty metric rises by 0.8. The count of distinct operands increases by one, and the overall effort metric sees a growth of 343.13. The length of the code increases by nine units, and the level metric decreases slightly by 0.03. Other shifts include a reduction in the purity ratio by 0.26 and an increase in the estimated time required by 19.06. The total occurrences of operands and operators grow by four and five, respectively, while the vocabulary expands by one. Finally, the code's volume increases by 40.09. These metrics demonstrate that introducing a new function generally increases the code's complexity and size, with vocabulary and operand counts having the most significant impact.

Changes in lines-of-code (LOC) metrics are also observed. The number of commented lines decreases by one, and their average, maximum, and minimum values drop slightly. Meanwhile, logical lines of code increase by two, along with corresponding maximum and minimum values. Physical lines of code show an increase of three, and source lines of code grow by two, although the average slightly decreases. These shifts indicate that some lines have been relocated into the new function, reflecting the structural changes made to the code.

The Maintainability Index (MI) metrics reveal a slight decline due to the reorganization. The original MI value decreases by 5.73, the SEI MI drops by 35.8, and the Visual Studio MI reduces by 3.35. These changes suggest a marginal reduction in maintainability, likely due to the increase in complexity and the redistribution of code.

Finally, function-related counts highlight the introduction of the new function. The total number of functions increases by one, as does the average number of functions per class or module, which rises by 0.17. The total number of methods also increases by one, with the average reflecting a similar uptick.

Although extracting a function introduces slight increases in code complexity and decreases maintainability metrics, these effects are usually outweighed by the benefits of improved code reuse, readability, and modularity. The resulting code is often easier to manage, understand, and extend.

\subsection{115. Inline Function}

The "Inline Function" pattern involves replacing a function call with the function's body directly in the code. This is typically done to eliminate unnecessary abstractions, simplify code by reducing indirection, or improve performance in specific scenarios. By inlining a function, developers make the implementation more visible, though this can lead to increased duplication if not used judiciously.

When applying this pattern, Cognitive Complexity decreases. Specifically, the average, maximum, and total values for this metric decrease by 0.5, 1, and 1, respectively. Similarly, Cyclomatic Complexity also decreases, with reductions of 0.33 for the average, 1 for the maximum, and 1 for the total. These changes indicate a slight simplification in the code's logic and flow.

Halstead metrics show a more nuanced impact. The estimated number of bugs increases slightly by 0.01, while difficulty decreases by 0.7. The count of distinct operands increases by 3, while distinct operators decrease by 2. Effort required to understand the code grows by 263.42, and the length of the code increases by 13 units. The level metric experiences a small increase of 0.02, while the purity ratio decreases by 0.5. The estimated time required rises by 14.63. Operand occurrences increase by 7, while operator occurrences increase by 6. The vocabulary metric expands by 1, and volume increases by 56.44. These changes reflect the replacement of a function call with explicit code, leading to more verbose code that requires greater cognitive and computational effort to process.

Changes in line-of-code (LOC) metrics further highlight the impact of inlining. Logical lines of code (lloc) increase by 2, and their average, maximum, and minimum values also grow by 0.67, 4, and 4, respectively. Physical lines of code (ploc) increase by 3, with similar changes in their average, maximum, and minimum values, which increase by 1, 6, and 6, respectively. Source lines of code (sloc) also grow by 3, with corresponding increases in their averages and extremes. These shifts reflect the expansion of the codebase due to the insertion of the function body directly into the calling site.

Maintainability Index metrics decrease as a result of inlining. The original MI value drops by 8.49, the SEI MI decreases by 12.34, and the Visual Studio MI falls by 4.96. These reductions suggest a decline in the code's maintainability, likely due to the increased size and complexity.

Finally, metrics related to the number of methods also show a decrease. The average and maximum number of methods decrease by 1, while the total number of methods decreases by 2. This is consistent with the removal of a standalone function as its content is moved into the calling site.

Overall, while inlining a function can reduce complexity and improve readability in certain contexts, it can also lead to code duplication and reduced maintainability. This pattern should be used selectively, ensuring the trade-offs align with the project's goals.

\subsection{119. Extract Variable}

The "Extract Variable" pattern involves taking a complex expression or a repeated value and assigning it to a new variable. This pattern helps to make the code more readable and maintainable by providing a meaningful name to intermediate results, which can clarify the intent behind the calculation. It also reduces redundancy, especially when the same value or expression is used multiple times, making the code easier to modify and less error-prone in the future.

When this pattern is applied, it impacts several software metrics, particularly those in Halstead's metrics. Halstead's bug count increases slightly by 0.01, indicating a small increase in complexity. The difficulty metric rises by 0.16, suggesting that the addition of a new variable adds some minor complexity. The number of distinct operands increases by 4, reflecting the introduction of new variables, while the number of distinct operators increases by 2, which likely corresponds to the use of the new variable in expressions. Effort, which measures the cognitive load of understanding the code, increases by 405.37, and the length of the code grows by 6 units. These changes imply that the code is slightly more complex due to the added variable, but it is now more explicit and easier to follow.

The level of the code remains unchanged, indicating no significant shift in its structural complexity. The purity ratio, which reflects how much of the code consists of operations versus variables, increases by 0.38. This suggests that the extracted variable helps in making the code more readable and reduces the ratio of complex expressions. Time increases by 22.52, indicating that the cognitive load for understanding the code has risen, albeit moderately. The total occurrences of operands and operators increase by 1 and 5, respectively, due to the additional variable. Vocabulary, which measures the variety of identifiers used, increases by 6, while the volume of the code (a measure of the total complexity) increases by 46.54.

In terms of maintainability, the Maintainability Index (MI) metrics show a slight decrease. The original MI value decreases by 0.94, the SEI MI drops by 1.35, and the Visual Studio MI decreases by 0.55. This reduction indicates that while the code is more explicit with the new variable, the overall maintainability has slightly decreased due to the added complexity and size.

Overall, the "Extract Variable" pattern can enhance code clarity and reduce redundancy, but it may slightly increase the overall complexity and reduce maintainability. It is a useful technique when it leads to better-structured and more understandable code, especially in cases where expressions are reused or difficult to interpret without intermediate variables.

\subsection{123. Inline Variable}

The "Inline Variable" pattern is the reverse of the "Extract Variable" pattern. It involves replacing a variable with the expression or value it holds, eliminating the need for the variable altogether. This pattern is often used when a variable is only used once or in very few places, and its value is simple enough to be directly incorporated into the expression. The goal is to simplify the code and reduce the overhead of unnecessary variables, potentially making the code more concise.

In terms of Halstead metrics, inlining a variable leads to several decreases. The bug count decreases slightly by 0.01, and the difficulty metric drops significantly by 2.5, indicating a reduction in the complexity of the code. The number of distinct operators decreases by 2, reflecting fewer components in the expression. Effort, which measures the cognitive load required to understand the code, decreases by 146.33, and the length of the code reduces by 5 units, suggesting that the code is now more compact. The level metric increases by 0.28, indicating a slight improvement in the structural clarity of the code. The purity ratio increases by 0.19, implying that the code has become more focused on logic and less dependent on variables. The time required to understand the code decreases by 8.13, showing that the code is simpler to read and process. The total occurrences of operands and operators decrease by 2 and 3, respectively, as the redundant variable is removed. Vocabulary, which tracks the number of distinct identifiers used, decreases by 2, and the overall volume of the code decreases by 19.19, suggesting that the code is now smaller and less complex.

Changes in lines of code (LOC) metrics reflect the reduced code size. The number of physical lines of code (ploc) decreases by 1, and the average, maximum, and minimum values for ploc all decrease by 1 as well. Similarly, source lines of code (sloc) decrease by 1, with corresponding reductions in their average, maximum, and minimum values. These reductions indicate that by inlining the variable, the code has become more streamlined and concise.

The Maintainability Index (MI) shows significant improvements. The original MI increases by 14.28, the SEI MI improves by 20.61, and the Visual Studio MI rises by 8.35. These increases suggest that inlining the variable has made the code more maintainable, easier to understand, and less cluttered with unnecessary elements.

Overall, the "Inline Variable" pattern is useful when a variable is redundant or adds unnecessary complexity to the code. It can lead to simpler, more concise code and may improve maintainability, but it should be applied carefully to avoid making the code harder to read in cases where the variable's meaning adds clarity.

\subsection{132. Encapsulate Variable}

The "Encapsulate Variable" pattern involves wrapping a variable with getter and setter methods or encapsulating its access through a dedicated class or function. This pattern is typically used when a variable needs to be protected from direct access, either to enforce constraints on its values or to provide additional functionality when the variable is read or written. Encapsulation enhances the maintainability and flexibility of code by allowing changes to the internal representation of the data without affecting external code that interacts with it. This pattern is especially useful when the logic surrounding a variable's access needs to evolve over time.

In terms of Cyclomatic Complexity, we observed an increase in the sum by 2. This increase indicates that the logic has become more complex, likely due to the introduction of getter and setter methods, which add additional control flow paths.

For Halstead metrics, there are several noticeable changes. The bug count increases by 0.02, reflecting a slight increase in the complexity of the code. Difficulty rises by 3.88, suggesting that encapsulating the variable introduces a level of abstraction that makes the code harder to understand. The number of distinct operands increases by 3, while the distinct operators count rises by 4, as new methods or functions are introduced to manage the variable. The effort required to understand the code grows by 735.51, reflecting the added complexity of managing access to the encapsulated variable. The length of the code increases by 18 units due to the additional methods or accessors. The level metric decreases by -0.19, implying that the overall clarity or simplicity of the code has slightly decreased. The purity ratio decreases by -0.35, reflecting a higher ratio of operations to variables. Time increases by 40.86, indicating a higher cognitive load required to process the code. The total occurrences of operands and operators rise by 6 and 12, respectively, and the vocabulary increases by 7, reflecting the additional components introduced by encapsulating the variable. Volume increases by 83.58, showing the growth in the code's overall complexity.

In terms of Lines of Code (LOC), logical lines of code (lloc) increase by 6, and the average, maximum, and minimum values for lloc grow by 2 each. Similarly, physical lines of code (ploc) increase by 2, and source lines of code (sloc) grow by 2 as well, due to the added methods or functions for encapsulating the variable.

For Maintainability Index (MI), we observe a significant decrease. The original MI decreases by -23.99, the SEI MI decreases by -34.41, and the Visual Studio MI drops by -14.03. These reductions suggest that the added complexity of encapsulating the variable makes the code harder to maintain, as more methods or functions are involved in the access and manipulation of the variable.

In terms of the Number of Methods, we see that the average number of methods increases by 0.5, the maximum number of methods increases by 1, and the total number of methods grows by 1. This is consistent with the introduction of getter and setter methods or additional access mechanisms.

Additionally, there are increases in the number of functions. The average number of functions increases by 0.67, and the total number of functions grows by 2, reflecting the added encapsulation logic.

Overall, the "Encapsulate Variable" pattern adds significant complexity to the code. While it provides benefits in terms of data protection and flexibility, it also increases the cognitive load, the size of the code, and potentially decreases maintainability. This pattern should be applied carefully, balancing the need for encapsulation with the goal of keeping the code as simple and maintainable as possible.

\subsection{140. Introduce Parameter Object}

The "Introduce Parameter Object" pattern involves replacing a group of parameters that are often passed together into a single object. Instead of passing multiple parameters to a method or function, a parameter object encapsulates all related parameters into one cohesive object. This pattern is especially useful when a method takes a large number of parameters, particularly when some of these parameters are related and logically belong together. By grouping them into an object, the method signature becomes simpler and more manageable, and the code is easier to maintain and extend.

The Halstead metrics show a decrease in several areas, indicating a reduction in complexity. The bug count decreases by -0.01, and the difficulty of the code decreases by -1.35, suggesting that the overall complexity is lowered by consolidating parameters into an object. The number of distinct operands and operators both decreases by 1, reflecting the simplification of the method's interface. Effort also decreases by -144.9, indicating that less cognitive load is required to understand and maintain the code. The length of the code decreases by -6 units, further showing the reduction in complexity. The level metric increases by 0.17, which suggests that the code is slightly easier to follow. The purity ratio decreases by -0.08, and time decreases by -8.05, indicating that the code is now less complex and easier to read. The total occurrences of operands and operators decrease by -3, and vocabulary decreases by -2, reflecting the simplification of the method signature. Volume also decreases by -24.46, pointing to a more compact and streamlined codebase.

In terms of Maintainability Index (MI), we see a positive impact. The original MI increases by 2.38, the SEI MI increases by 3.44, and the Visual Studio MI increases by 1.39. These improvements suggest that consolidating parameters into an object has made the code easier to maintain and understand.

For the Number of Methods, we see some reductions. The average number of methods decreases by -1, the maximum number of methods decreases by -1, and the total number of methods decreases by -3. This reduction suggests that the code has become more focused and that some methods, previously dealing with many parameters, have been simplified or consolidated.

Overall, the "Introduce Parameter Object" pattern is a useful technique for simplifying method signatures, improving code readability, and reducing complexity. By grouping related parameters into a single object, the code becomes more maintainable and easier to modify in the future. However, care must be taken to ensure that the new object does not introduce unnecessary complexity and that it is used in contexts where it truly simplifies the code.

\subsection{144. Combine Functions Into Class}

The "Combine Functions Into Class" pattern involves taking a set of related functions and grouping them into a single class. This pattern is useful when functions share common state or logic that can be better organized within an object-oriented structure. Instead of having these functions scattered across different parts of the codebase, encapsulating them within a class allows for better cohesion and promotes the object-oriented principle of encapsulation. A class can hold shared state (via fields or properties), and methods can operate on this state, improving code organization, maintainability, and reuse.

For Cyclomatic Complexity, we observe that the sum metric increased by 1. This indicates that the introduction of a class has slightly increased the complexity, likely due to additional logic required to manage the class state and behavior.

In terms of Halstead metrics, there are some noticeable decreases, suggesting simplification of the code. The bug count remained unchanged, but difficulty decreased by -1.25, indicating a reduction in the overall complexity of the code. The number of distinct operators decreased by 1, reflecting a decrease in the variety of operations required. Effort decreased by -66.31, showing that less cognitive load is now required to understand the code. The length of the code decreased by -4 units, reflecting a reduction in code duplication and increased cohesion. The level metric increased by 0.56, suggesting that the code is easier to follow. The purity ratio increased by 0.06, implying that the code is more focused on its core functionality. Time decreased by -3.68, indicating that the code is now more efficient in terms of both readability and processing. The total occurrences of operands and operators both decreased by -2, and vocabulary decreased by -1, reflecting the simplification of the code. Volume decreased by -13.68, showing a reduction in the overall size and complexity of the codebase.

For Lines of Code (LOC), there were several changes. The average logical lines of code (lloc) decreased by -0.15, and the maximum and minimum values for lloc increased by 2, suggesting that the class has added some size but also resulted in more structured code. Physical lines of code (ploc) increased by 2, and the average, maximum, and minimum values for ploc all grew, indicating that the new class is adding more code. Similarly, source lines of code (sloc) increased by 2, reflecting the added class structure.

The Maintainability Index (MI) decreased. The original MI decreased by -6.46, the SEI MI decreased by -9.22, and the Visual Studio MI decreased by -3.78. These decreases suggest that while the introduction of a class improves the logical organization of the code, it may have made the code slightly harder to maintain due to the added complexity of managing the class and its interactions.

In terms of the Number of Methods, the average number of methods decreased by -1, the maximum number of methods decreased by -1, and the total number of methods decreased by -3. This indicates that the methods from the individual functions have been consolidated into the class, resulting in a reduction in the number of standalone methods.

Finally, the Number of Functions also saw a decrease. The average number of functions decreased by -1, and the total number of functions decreased by -3, reflecting the consolidation of multiple functions into a single class.

Overall, the "Combine Functions Into Class" pattern can help simplify code structure by grouping related functions and data together. While it might increase the size of the codebase slightly and reduce some maintainability metrics, it provides better cohesion and clarity, which can make the code easier to extend, test, and maintain in the long term.

\subsection{149. Combine Functions Into Transform}

The "Combine Functions Into Class" pattern involves taking a set of related functions and grouping them into a single transform function.
This pattern is useful when functions exits and entries are used together in a chain. Instead of having these functions scattered across different parts of the codebase, encapsulating them within a transform function allows for better cohesion and a single point of interaction for the result object.

Cyclomatic Complexity: The sum variable decreases by -1, indicating a reduction in the complexity of the code structure. This decrease might suggest that some conditional logic or branching has been simplified or eliminated.

Halstead Metrics: Several metrics show increases. The bugs count increases by 0.03, difficulty by 4.55, and effort by 949.27, reflecting an increase in the cognitive effort required to understand or modify the code. The number of distinct operands and operators increases significantly, with distinct operands rising by 8 and distinct operators by 5. This might indicate that the refactor introduced more varied operations or variables. The volume of the code increased by 127.08, which indicates that the codebase has grown in size, likely due to more complex operations or additional functionality.

The Maintainability Index (MI) dropped, with original MI decreasing by -26.81, SEI MI decreasing by -38.78, and Visual Studio MI dropping by -15.68. These decreases suggest that the changes made to the code resulted in a less maintainable structure, possibly due to increased complexity or a larger codebase that is harder to navigate and understand.

Lines of Code metrics show some increases across different categories. Logical lines of code (lloc) increased by 2, with the average increasing by 1.33. Similarly, physical lines of code (ploc) increased by 4, with average values increasing as well. Source lines of code (sloc) also grew by 4. This suggests that the code restructuring involved the addition of more lines, possibly from new functions or operations added during the refactor.

In terms of Number of Methods, we see a mixed effect. The average number of methods increased by 1, which might suggest that the restructuring involved adding more methods, possibly for better modularization. The maximum number of methods increased by 1, and the sum of methods increased by 1 as well. However, the total number of functions decreased by -1, which might reflect the consolidation of previously separate functions into larger, more comprehensive ones.

Overall, while the changes brought some increase in complexity (as reflected in Halstead metrics and MI), they also brought a growth in the codebase's size and number of methods. These kinds of changes might be seen in situations where the code is refactored for better modularity, better encapsulation, or adding additional functionality, though it may come with trade-offs in terms of maintainability and cognitive complexity.

\subsection{154. Split Phase}

The last pattern in this work involves taking some sequence of code, usually performing some handful operations that are quite hard to read or understand - for example, regex strings, splitting an array and returning exactly the second or third object - and abstracting them
behind functions. This is common for large projects because it helps carrying out the most machine-like code behind a named function and allowing the maintainer to provide their intent in that block of code.

In this analysis, several key metrics were observed following a change in the code.

For Cyclomatic Complexity, the variable "sum" increased by 2. This suggests that the changes introduced additional decision points or branches in the code, which is typical when functionality is added or modified.

For Halstead Metrics, several significant shifts were noted. The variable "bugs" increased by 0.06, indicating a slight rise in the potential number of errors that could be present. The "difficulty" of understanding the code increased by 5.96, which points to the added complexity from the changes. Furthermore, there was an increase in both "distinct operands" (by 7) and "distinct operators" (by 5), showing that more unique variables and operations have been introduced. These changes were accompanied by an increase in "effort" (3489.34), "length" (38), and "volume" (215.77), which collectively reflect that the size and the effort needed to comprehend or modify the code have grown. However, the "level" of the code slightly decreased by -0.09, and the "purity ratio" also decreased by -0.07, suggesting a reduction in the simplicity of the code. Additionally, "time" increased by 193.85, reflecting that more time is required to process the code due to its expanded size and complexity.

In terms of Lines of Code, the "lloc" (logical lines of code) increased by 4, and the "ploc" (physical lines of code) increased by 9. These figures suggest that more code has been added, likely due to new operations or features being implemented. The "sloc" (source lines of code) also increased by 9, reinforcing the idea that the codebase has grown. The average values for "lloc", "ploc", and "sloc" all rose as well, pointing to an overall increase in the amount of code involved in the changes.

For the Maintainability Index, there was a significant decrease across all variations: the "mi\_original" dropped by -27.28, the "mi\_sei" dropped by -39.15, and the "mi\_visual\_studio" dropped by -15.95. These reductions indicate that the changes have made the code harder to maintain, likely due to the added complexity and volume of code.

In terms of Number of Methods, the total number of methods increased, with the "average" rising by 1, the "max" increasing by 1, and the "sum" rising by 2. This suggests that more methods have been added to the codebase, which may reflect new functionality or a restructuring of existing processes. Furthermore, the "functions" variable increased by 2, and the average number of functions grew by 0.67. These changes suggest that more functional units were introduced, which could lead to better modularity but also an increase in the overall complexity of the system.

Overall, these metrics indicate that the code has grown significantly in size and complexity, with more functionality being added and an increase in both the number of methods and lines of code. While this may improve modularity, it has also resulted in a decrease in maintainability, making the code more difficult to maintain and understand.
